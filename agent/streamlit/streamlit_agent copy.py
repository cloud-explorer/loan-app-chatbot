import io
import os
import re
import json
import time
import boto3
import base64
import string
import random
import requests
import streamlit as st
from streamlit_chat import message
import subprocess

from requests import request
from sigv4 import SigV4HttpRequester

def session_generator():
    # Generate random characters and digits
    digits = ''.join(random.choice(string.digits) for _ in range(4))  # Generating 4 random digits
    chars = ''.join(random.choice(string.ascii_lowercase) for _ in range(3))  # Generating 3 random characters
    
    # Construct the pattern (1a23b-4c)
    pattern = f"{digits[0]}{chars[0]}{digits[1:3]}{chars[1]}-{digits[3]}{chars[2]}"
    print("Session ID: " + str(pattern))

    return pattern

# Bedrock Variable
# agentId = os.environ['BEDROCK_AGENT_ID']
agentId = "PRTQZRJKMV"
# agentAliasId = os.environ['BEDROCK_AGENT_ALIAS_ID']
agentAliasId = "STCJZQXFDO"
#knowledgeBaseId = os.environ['BEDROCK_KB_ID']
#dataSourceId = os.environ['BEDROCK_DS_ID']

# Other Resource Variables
# knowledge_base_s3_bucket = os.environ['KB_BUCKET_NAME']

# agents = bedrock-agent-runtime.us-east-1.amazonaws.com
# knowledgebases = bedrock-agent.us-east-1.amazonaws.com
# kb_url = f'https://bedrock-agent.us-east-1.amazonaws.com/knowledgebases/{knowledgeBaseId}/datasources/{dataSourceId}/ingestionjobs/'

# AWS Session and Clients Instantiation
session = boto3.Session("us-east-1")
agent_client = boto3.client('bedrock-agent-runtime')
# agent_client = boto3.client('bedrock-agent')
# s3_client = boto3.client('s3',region_name=os.environ['AWS_REGION'],config=boto3.session.Config(signature_version='s3v4',))

# Streamlit CSS
style = """
    <style>
        html, body, [class*="css"] {
            font-family: 'Roboto', sans-serif !important; 
            font-size: 18px;
            font-weight: 500;
            background-color: #091747;
        }
        .text-with-bg {
            color: white;
            padding: 10px;
            border-radius: 5px;
        }
        .stTextInput {{
            position: fixed;
            bottom: 3rem;
        }}
    </style>
"""
st.markdown(style, unsafe_allow_html=True)

# Streamlit App Layout
st.title('Bedrock Mortgage Agent')
st.subheader('Powered by Amazon Bedrock')
logo = "bedrock_logo.png"
st.sidebar.image(logo, width=300, output_format='PNG')
# st.sidebar.markdown(style, unsafe_allow_html=True)
st.sidebar.subheader('**About this Demo**')
st.sidebar.markdown('<p class="text-with-bg">The Bedrock Mortgage Solution uses Agents and Knowledge base for Amazon Bedrock. This agent can assist customers at Fannie Mae by providing information and support related to mortgage products, application processes, status updates, and details about loan terms and eligibility. They aim to deliver excellent service, guiding customers through homebuying and mortgage financing while being equipped to address queries on refinance, modification options, and mortgage assistance programs. </p>', unsafe_allow_html=True)

with st.expander("ℹ️ Disclaimer"):
    st.caption(
        "This demo uses an Amazon Bedrock foundation model and is not intended to collect any personally identifiable information (PII) from users. Please do not provide any PII when interacting with this demo. The content generated by this demo is for informational purposes only."
    )

def bedrock_agent(query, sessionId):
    if query is not None:

        agent_query = {
            "inputText": query,   
            "enableTrace": True,
        }

        # send request
        print("Invoking Agent with query: " + query)
        agent_url = f'https://bedrock-agent-runtime.us-east-1.amazonaws.com/agents/{agentId}/agentAliases/{agentAliasId}/sessions/{sessionId}/text'
        requester = SigV4HttpRequester()
        response = requester.send_signed_request(
            url=agent_url,
            method='POST',
            service='bedrock',
            headers={
                'content-type': 'application/json', 
                'accept': 'application/json',
            },
            region='us-east-1',
            body=json.dumps(agent_query)
        )
        
        if response.status_code == 200:
            # Parse sig4_request Response
            response_string = ""
            for line in response.iter_content():
                try:
                    response_string += line.decode(encoding='utf-8')
                except:
                    continue

            split_response = response_string.split(":message-type")
            last_response = split_response[-1]
            try:
                encoded_last_response = last_response.split("\"")[3]
                print("encoded_last_response: " + str(encoded_last_response))
                if encoded_last_response == "citations":
                    # Find the start and end indices of the JSON content
                    start_index = last_response.find('{')
                    end_index = last_response.rfind('}')

                    # Extract the JSON content
                    json_content = last_response[start_index:end_index + 1]

                    try:
                        data = json.loads(json_content)
                        final_response = data['attribution']['citations'][0]['generatedResponsePart']['textResponsePart']['text']
                    except json.decoder.JSONDecodeError as e:
                        print(f"JSON decoding error: {e}")
                    except KeyError as e:
                        print(f"KeyError: {e}")
                else:
                    decoded = base64.b64decode(encoded_last_response)
                    final_response = decoded.decode('utf-8')
            except base64.binascii.Error as e:
                print(f"Base64 decoding error: {e}")
                final_response = last_response  # Or assign a default value

        print("Agent Response: " + final_response)
        return final_response

if "query" not in st.session_state:
    st.session_state.query = ""
def clear_text():
    st.session_state.query = st.session_state.widget
    st.session_state.widget = ""

if "user_prompt_history" not in st.session_state:
    st.session_state["user_prompt_history"] = []

if "chat_answers_history" not in st.session_state:
    st.session_state["chat_answers_history"] = []

# Main Execution Block
    if not "valid_inputs_received" in st.session_state:
        st.session_state["valid_inputs_received"] = False

def submit():  
    st.session_state.query = st.session_state.widget
    st.session_state.widget = ""

st.text_input("User Input", value="", key='widget', placeholder="Hello! How can I help you?", label_visibility="visible", on_change=submit)
query = st.session_state.get("query", "")
agent_response = None 

if query:
    if st.session_state.get("user_prompt_history") != query and query != "":
        if "session_id" not in st.session_state:
            st.session_state["session_id"] = session_generator()

        sessionId = st.session_state["session_id"]
        message(query, is_user=True)
        
        with st.spinner("Looking for answers..."):
            agent_response = bedrock_agent(query, sessionId)
            # st.session_state["previous_query"] = query
            st.session_state["user_prompt_history"].append(query)
            if agent_response is not None:
                # st.write("Agent's Response:", agent_response)
                st.session_state["chat_answers_history"].append(agent_response)

if st.session_state["chat_answers_history"]:
    for generated_response, user_query in zip(
        st.session_state["chat_answers_history"],
        st.session_state["user_prompt_history"],
    ):
        message(query, is_user=True)
        message(generated_response)

# clear the query
query = ""
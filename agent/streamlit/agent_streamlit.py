import io
import os
import re
import json
import time
import boto3
import base64
import string
import random
import requests
import streamlit as st

from requests import request
from sigv4 import SigV4HttpRequester

def session_generator():
    # Generate random characters and digits
    digits = ''.join(random.choice(string.digits) for _ in range(4))  # Generating 4 random digits
    chars = ''.join(random.choice(string.ascii_lowercase) for _ in range(3))  # Generating 3 random characters
    
    # Construct the pattern (1a23b-4c)
    pattern = f"{digits[0]}{chars[0]}{digits[1:3]}{chars[1]}-{digits[3]}{chars[2]}"
    print("Session ID: " + str(pattern))

    return pattern

# Bedrock Variable
agentId = os.environ['BEDROCK_AGENT_ID']
agentAliasId = os.environ['BEDROCK_AGENT_ALIAS_ID']
knowledgeBaseId = os.environ['BEDROCK_KB_ID']
dataSourceId = os.environ['BEDROCK_DS_ID']

# Other Resource Variables
knowledge_base_s3_bucket = os.environ['KB_BUCKET_NAME']

# agents = bedrock-agent-runtime.us-east-1.amazonaws.com
# knowledgebases = bedrock-agent.us-east-1.amazonaws.com
kb_url = f'https://bedrock-agent.us-east-1.amazonaws.com/knowledgebases/{knowledgeBaseId}/datasources/{dataSourceId}/ingestionjobs/'

# AWS Session and Clients Instantiation
session = boto3.Session(region_name=os.environ['AWS_REGION'])
agent_client = boto3.client('bedrock-agent-runtime')
# agent_client = boto3.client('bedrock-agent')
s3_client = boto3.client('s3',region_name=os.environ['AWS_REGION'],config=boto3.session.Config(signature_version='s3v4',))

# Streamlit CSS
custom_css = """
    <style>
        .text-with-bg {
        color: white;
            background-color: #1c2e4a; /* Change this to your desired background color */
            padding: 10px;
            border-radius: 5px;
        }
    </style>
"""

# Streamlit App Layout
st.title('Bedrock Mortgage Agent')
st.subheader('Powered by coffee and Amazon Bedrock')
st.info("**DISCLAIMER:** This demo uses an Amazon Bedrock foundation model and is not intended to collect any personally identifiable information (PII) from users. Please do not provide any PII when interacting with this demo. The content generated by this demo is for informational purposes only.")
idp_logo = "bedrock_logo.png"
st.sidebar.image(idp_logo, width=300, output_format='PNG')
st.sidebar.markdown(custom_css, unsafe_allow_html=True)
st.sidebar.subheader('**About this Demo**')
st.sidebar.markdown('<p class="text-with-bg">The Bedrock Mortgage Solution uses Agents and Knowledge base for Amazon Bedrock to assist human Mortgage agents by creating new claims, sending pending document reminders and gathering evidence for claims, and providing access to claims data, repair estimates, FAQs, and other Mortgage documents. </p>', unsafe_allow_html=True)

# Helper Functions
def show_pdf(uploaded_file):
    if uploaded_file is not None:
        file_contents = uploaded_file.getvalue()

        # Convert the file content to base64
        base64_pdf = base64.b64encode(file_contents).decode('utf-8')
        
        # Display the PDF
        pdf_display = f'<iframe src="data:application/pdf;base64,{base64_pdf}" width="500" height="500" type="application/pdf"></iframe>'
        st.markdown(pdf_display, unsafe_allow_html=True)

# Invoke Agent
def bedrock_agent(query, sessionId):
    if query is not None:

        agent_query = {
            "inputText": query,   
            "enableTrace": True,
        }

        # send request
        print("Invoking Agent with query: " + query)
        agent_url = f'https://bedrock-agent-runtime.us-east-1.amazonaws.com/agents/{agentId}/agentAliases/{agentAliasId}/sessions/{sessionId}/text'
        requester = SigV4HttpRequester()
        response = requester.send_signed_request(
            url=agent_url,
            method='POST',
            service='bedrock',
            headers={
                'content-type': 'application/json', 
                'accept': 'application/json',
            },
            region='us-east-1',
            body=json.dumps(agent_query)
        )
        
        if response.status_code == 200:
            # Parse sig4_request Response
            response_string = ""
            for line in response.iter_content():
                try:
                    response_string += line.decode(encoding='utf-8')
                except:
                    continue

            split_response = response_string.split(":message-type")
            last_response = split_response[-1]
            try:
                encoded_last_response = last_response.split("\"")[3]
                print("encoded_last_response: " + str(encoded_last_response))
                if encoded_last_response == "citations":
                    # Find the start and end indices of the JSON content
                    start_index = last_response.find('{')
                    end_index = last_response.rfind('}')

                    # Extract the JSON content
                    json_content = last_response[start_index:end_index + 1]

                    try:
                        data = json.loads(json_content)
                        final_response = data['attribution']['citations'][0]['generatedResponsePart']['textResponsePart']['text']
                    except json.decoder.JSONDecodeError as e:
                        print(f"JSON decoding error: {e}")
                    except KeyError as e:
                        print(f"KeyError: {e}")
                else:
                    decoded = base64.b64decode(encoded_last_response)
                    final_response = decoded.decode('utf-8')
            except base64.binascii.Error as e:
                print(f"Base64 decoding error: {e}")
                final_response = last_response  # Or assign a default value

        print("Agent Response: " + final_response)
        return final_response

def update_knowledge_base(file_content, bucket_name, s3_file_name):
    print("Syncing Knowledge Base Data Source")

    try:
        # Wrap the bytes content in an in-memory file-like object
        file_obj = io.BytesIO(file_content)

        s3_client.upload_fileobj(file_obj, bucket_name, s3_file_name)
        st.success(f"File uploaded successfully to S3 bucket '{bucket_name}' as '{s3_file_name}'")
    except Exception as e:
        st.error(f"Error uploading file to S3: {e}")
    finally:
        file_obj.close()  # Close the file-like object after upload

    # Define HTTP request payload (StartIngestionJobRequestContent)
    description = "Programmatic update of Bedrock Knowledge Base Data Source"

    kb_update = {
        "description": description,   
    }

    # agent_client.start_ingestion_job(knowledgeBaseId=knowledgeBaseId, dataSourceId=dataSourceId, description=description)
    print("Starting Ingestion Job")
    requester = SigV4HttpRequester()
    response = requester.send_signed_request(
        url=kb_url,
        method='PUT',
        service='bedrock',
        headers={
            'content-type': 'application/json', 
            'accept': 'application/json',
        },
        region='us-east-1',
        body=json.dumps(kb_update)
    )    
    
    print("Finished Ingestion Job: " + str(response))
    return response

def check_ingestion_job_status():
    headers = {
        "Content-type": "application/json",
        # Add any necessary headers here
    }

    status = ""
    while status != "complete":
        try:
            response = agent_client.list_ingestion_jobs(
                knowledgeBaseId=knowledgeBaseId,
                dataSourceId=dataSourceId,
            )

            if response.status_code == 200:
                job_status = response.json()["ingestionJobSummaries"][0]["status"]
                if job_status == "complete":
                    st.write(f"Ingestion Job Status: {job_status}")
                    break
                else:
                    st.write(f"Polling... Current Job Status: {job_status}")
            else:
                st.write(f"Error: {response.status_code} - {response.text}")
        except Exception as e:
            st.write(f"An error occurred: {e}")

        time.sleep(5)  # Poll every 5 seconds (adjust as needed)

def main():
    # Main Execution Block
    if not "valid_inputs_received" in st.session_state:
        st.session_state["valid_inputs_received"] = False

    # --- Agent Q&A ---
    st.subheader('Agent for Amazon Bedrock - Prompt Input')
    query = st.text_input("User Input", value="", placeholder="What can the agent help you with?", label_visibility="visible")
    agent_response = None  # Initialize agent_response variable
    
    if st.session_state.get("previous_query") != query and query != "":
        if "session_id" not in st.session_state:
            st.session_state["session_id"] = session_generator()

        sessionId = st.session_state["session_id"]

        agent_response = bedrock_agent(query, sessionId)
        st.session_state["previous_query"] = query  # Update previous_query if query changes

    if agent_response is not None:
        st.write("Agent's Response:", agent_response)

    # --- Knowledge Base Update ---
    st.subheader("Knowledge Base for Amazon Bedrock - File Upload")
    uploaded_file = st.file_uploader("Upload Document", type=["csv", "doc", "docx", "htm", "html", "md", "pdf", "txt", "xls", "xlsx"])

    if uploaded_file is not None:
        with st.expander("Uploaded File üìÅ"):
            show_pdf(uploaded_file)

        file_details = {"FileName": uploaded_file.name, "FileType": uploaded_file.type}
        file_name = "knowledge-base-assets/" + file_details["FileName"]

        # Display the contents of the file (for text-based formats like txt, pdf, docx)
        if uploaded_file.type == "text/plain":
            text = uploaded_file.read()
            st.write("Content:")
            st.write(text.decode("utf-8"))  # Decode bytes to string for display

        print("Uploading document to Amazon S3")
        file_contents = uploaded_file.getvalue()
        update_knowledge_base(file_contents, knowledge_base_s3_bucket, file_name)
        check_ingestion_job_status()

# Call the main function to run the app
if __name__ == "__main__":
    main()
